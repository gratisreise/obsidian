
### React-Dom

Browser[dom] <---> Elm Runtime[vdom]

### VDOM
--- 
HTML
initial model =>  vdom(코드) =>  dom띄워주기 => 실제돔을 눌렀다(이벤트) => vdom(코드)
=> 프론트 서버에서 => 변화메세지를 준다 => 기능 코드를 다시준다 => 바뀐 부분만 바꿔서 로드 시킨다. => 효율을 위해서 =>

vdom과 dom은 다르다 vdom의 목적은 dom을생성하기 위해서 
메모리를 많이 먹는다?: vue vs react




### SPA(Single Page Application)
---

브라우저를 벗어난 곳에서 자바스크립트를 쓰게 하는 것 : 노드js => 이벤트 그리딩?? => 빠르다?
노드는 빠르다 => 인터프리터 + 싱글스레드 => 빠르다? => 뻗기는 쉽다?
npm 잘 가져다 써야함 잘못 가져다 쓰면 완전 망함


```shell
npx create-react-app
/**
cli에서 e(environment): 환경변수 || x(execute): 실행
*/
```


node_modules: 라이브러리 모음
npm warn : ~~~ 오류가 있을 수도 있다.
리액트는 라이브러리로 동작을 내가 설계해서 자유롭게 작성한다. 따라서 사람마다 작성하는 규칙이 상이 하기 쉽다 => 팀원들끼리 조율하여 규칙을 만들거나 react의 프레임워크인 nextJs를 써서 컨벤션을 정한다.

JSX(JavaScript XML) => 클래스 조작을 함수형 조작으로 바꿔주는 라이브러리



### JSX 문법
리액트의 긴 코드를 줄이기 위해 쓰이는 문법

호이스팅: 전역에 이름을 미리 등록하는 것

### SPA
클라이언트와 가까우니 수정이 자주 일어난다.
자바: 클래스 => 설계도 멤버변수, 멤버메서드
자스: 컴포넌트 => state: 값 , 인스턴스 만들어서 사용하는 것과 같다고 생각하자


자스를 잘하려면 자스의 동작원리가 중요하다

#### 컴포넌트
- 만드는 방법1
angular의 단점 보완 -> 리액트
기술이 넘어갈 때 성숙도를 따져야 한다.(프로그램완성도, 사용자수, 지원하는 패키지들 수)
리액트 mvp 모델 : one-way 바인딩
뷰 mvvp 모델: two-way 바인딩
옵저버의 유무로 인한 차이


- 만드는 방법2




src: 소스코드 => src부터 찾아서 하면 된다.
